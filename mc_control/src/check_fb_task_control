#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
from sensor_msgs.msg import JointState
from utils.markers import *
from utils.mc_legs import *
from utils.mc_robot import mini_cheetah
import numpy as np
from cvxopt import solvers
from cvxopt import matrix
from copy import copy

from qpoases import PyQProblemB as QProblemB
from qpoases import PyOptions as Options
from qpoases import PyPrintLevel as PrintLevel

# Node Creation 
rospy.init_node('mc_fb_test')

# Publish the joint states
pub = rospy.Publisher('/joint_states',JointState,queue_size=10)

# Joint names 
jnames = [ 'x','y','z','w','ex','ey','ez',
          'RL_hip_joint', 'RL_thigh_joint', 'RL_calf_joint', 
		  'FL_hip_joint', 'FL_thigh_joint', 'FL_calf_joint',
   		  'RR_hip_joint', 'RR_thigh_joint', 'RR_calf_joint', 
		  'FR_hip_joint', 'FR_thigh_joint', 'FR_calf_joint']


# Load initial Values 
x_b0 = np.array([0,0,0.4424,1,0,0,0])
q_legs0 = np.array([0,0,0, # RL
                    0,0,0, # FL
                    0,0,0, # RR
                    0,0,0]) # FR
q0 = np.concatenate((x_b0,q_legs0))

# Initialize the mini_cheetah class
robot = mini_cheetah()
robot.step_update(q0)

# Ball markers 
bmarker1 = BallMarker(color['RED'])

# Create the message 
joints = JointState()
joints.name = jnames 
joints.position = q0

# Obtain actual position
pos_fr = robot.leg_position('FR',type='pos')
pos_rr = robot.leg_position('RR',type='pos')
pos_fl = robot.leg_position('FL',type='pos')
pos_rl = robot.leg_position('RL',type='pos')

# Obtain desired positions for each leg only two tasks 
posd_fr = copy(pos_fr)
posd_fr[2] += 0.15
posd_fr[1] -= 0.05


posd_rr = copy(pos_rr)
posd_fl = copy(pos_fl)
posd_rl = copy(pos_rl)

T_posdrr = np.array([[1,0,0,posd_fr[0]], 
                     [0,1,0,posd_fr[1]],
                     [0,0,1,posd_fr[2]], 
                     [1,0,0,0]])

# Constants generated for the kinematic task control
# Lambdas  (K control)
l_1 = 0.5
l_2 = 0.5
l_3 = 0.5
l_4 = 0.5

# Weights for each task
w_1 = 1.0 
w_2 = 1.0
w_3 = 1.0
w_4 = 1.0

# ======================
#  Limits of the robot
# ======================

qmin = np.array([-1.4, -1.4, -2.5,
                 -1.4, -1.4, -2.5, 
                 -1.4, -1.4, -2.5,
                 -1.4, -1.4, -2.5])
qmax = -qmin


dqmax = 10.0*np.ones((12))
dqmin = -dqmax

# Bounds for the floating base
low = -1e4
high = 1e04
lfb = np.array([low, low, low, low, low, low, low])
ufb = np.array([high, high, high, high, high, high, high])
        


q_robot = copy(q0)

# Configuration of the loop

f = 100.0
dt = 1./f
rate = rospy.Rate(f)

while not rospy.is_shutdown():

    # Calculate Error
    # Obtain error for tasks 
    e_1 = robot.error_position_leg(posd_fr,'FR')
    e_2 = robot.error_position_leg(posd_rr,'RR')
    e_3 = robot.error_position_leg(posd_fl,'FL')
    e_4 = robot.error_position_leg(posd_rl,'RL')
    

    # Derivate the error
    e_1_dot = l_1*e_1
    e_2_dot = l_2*e_2
    e_3_dot = l_3*e_3
    e_4_dot = l_4*e_4

    # Jacobian for each task
    J_1 = robot.leg_jacobian_position('FR')
    J_2 = robot.leg_jacobian_position('RR')
    J_3 = robot.leg_jacobian_position('FL')
    J_4 = robot.leg_jacobian_position('RL')

    # Cuadrataic Programming
    P = w_1*(J_1.T).dot(J_1)  + w_2*(J_2.T).dot(J_2)  + w_3*(J_3.T).dot(J_3) + w_4*(J_4.T).dot(J_4)
    b = -2*(w_1*(J_1.T).dot(e_1_dot) + w_2*(J_2.T).dot(e_2_dot) + w_3*(J_3.T).dot(e_3_dot) + w_4*(J_4.T).dot(e_4_dot))


    lower_limits = np.maximum((qmin-q_robot[7:])/dt, dqmin)
    upper_limits = np.minimum((qmax-q_robot[7:])/dt, dqmax)
    lower_limits = np.hstack((lfb, lower_limits))
    upper_limits = np.hstack((ufb, upper_limits))
    # limits = np.hstack((lower_limits,upper_limits)) 
    # h = matrix(limits)
    # P = matrix(P)
    # b = matrix(b)

    # Solve the quadratic problem
    # sol = solvers.qp(P,b,G=G,h=h)
    # Solver
    solver = QProblemB(19)
    options = Options()
    options.setToMPC()
    options.printLevel = PrintLevel.LOW
    solver.setOptions(options)

    nWSR = np.array([10])
    solver.init(P, b, lower_limits, upper_limits, nWSR)
    q_dot = np.zeros(19)
    solver.getPrimalSolution(q_dot)
 
    # Integrate rotation
    Q_robot = q_robot[3:7]
    w = np.dot(TQb(Q_robot), q_dot[3:7])
    dth = np.linalg.norm(w)
    if abs(dth)>1e-9:
        u = w/dth
        dQ = np.array([np.cos(dth*dt/2.0), u[0]*np.sin(dth*dt/2.0),
                       u[1]*np.sin(dth*dt/2.0), u[2]*np.sin(dth*dt/2.0)])
        Q = quaternionMult(dQ, q_robot[3:7])
        q_robot[3:7] = Q    

    q_robot[0:3] = q_robot[0:3] + dt*q_dot[0:3]
    q_robot[7:] = q_robot[7:] + dt*q_dot[7:]

    robot.step_update(q_robot)


    joints.header.stamp = rospy.Time.now()
    joints.position = q_robot
    pub.publish(joints)
    bmarker1.position(T_posdrr)
    rate.sleep() 